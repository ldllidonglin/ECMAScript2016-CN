## 6.1 ECMAScript语言类型
ECMAScript语言类型就是指可以直接在由ECMAScript编写的程序中操作使用的值的类型，有以下几种：Undefined,Null,Boolean,String,Symbol,Number,Object。ECMAScript语言值有一一对应的ECMAScript语言类型
### 6.1.1 Undefined类型

Undefined类型只有一种值，就是undefined，任何变量在没有被赋值之前都有undefined值

### 6.1.2 Null类型

Null类型只有一种值，就是null

### 6.1.3 Boolean类型

Boolean 类型表示逻辑实体，有两个值，true 和 false。

### 6.1.4 String类型
The String type is the set of all ordered sequences of zero or more 16-bit unsigned integer values \(“elements”\) up to a maximum length of 253-1 elements.字符串类型通常被用于表示文本数据，这时String当中的每一个元素都被当作UTF-16编码的值。每个元素被当作一个在这个序列中的占位符。序列中的位置索引都是非负数。第一个元素的索引值是0，第二个元素是1，按此排列。String的length值就是其元素的个数，空字符串的length是0，所以它不包含任何元素。

在ECMAScript中解释运行String值时，其每一个元素都被当作UTF-16编码，然而，ECMAScript没有对String当中的元素作任何编码限制，所以他们可能被错误的解释运行。Operations that do not interpret String contents treat them as sequences of undifferentiated 16-bit unsigned integers。String.prototype.normalize（21.1.3.12）函数能按照指定的规则正规化String值。String.prototype.localeCompare（21.1.3.10）会在函数内把String值正规化。没有其他操作会隐式的正规化String值。只有显示指定规则或者本地语言规定才会发生这样的操作。

> 注意：这种设计实现的背后原理就是为了能让String的实现即简单又能尽可能的高性能。如果ECMAScript源代码被正规化像C语言那样，String也会被当作是已经正规化了的，只要他们不包含任何Unicode转义序列。
一些操作会把String内容当作UTF-16编码的Unicode代码点，在这种情况下，操作流程如下：


* 一个字符单元如果是在0到0xD7FF或者0xE000到0xFFFF范围内，会被解释为同样的值
* 一个两个字符的序列，当第一个字符c1在0xD800到0xDBFF范围中，并且第二个字符c2在0xDC00到0xDFFF中，是一个代理对，并且会被解释执行一个值为（c1-0xD800）× 0x400 + \(c2 - 0xDC00\) + 0x10000的代码代码单元（10.1.2）
* 一个字符单元在0xD800到0xDFFF范围中是，但是不是一个代理对，会被解释执行为同样的值  

### 6.1.5 Symbol类型

Symbol类型是一组非String值的集合，可以被当作Object属性的key值  
任意一个Symbol值都是独一无二并且是不可变的  
任意一个Symbol值都持有一个名叫\[\[Description\]\]的关联值，这个值要么是undefined，要么是String值

#### 6.1.5.1 Symbol特性

Symbol特性是Symbol值根据本规范算法规定的内置属性值，他们一般被当作规范扩展的那些点中属性的key值，除非另外规定，symbol特性都共享在8.2中。symbol特性都用@@name的形式标记，name值主要有如下表1如实

| 特性名 | 描述 | V值和作用 |
| --- | --- | --- |
| @@hasInstance | "Symbol.hasInstance" | 一个方法用来识别构造函数对象是否是构造函数的实例，在instance of 操作时调用 |
| @@isConcatSpreadable | "Symbol.isConcatSpreadable" | 一个布尔值，当为true时意味着它的array元素可以被Array.prototype.concat方法打平 |
| @@iterator | "Symbol.iterator" | 一个方法，给一个对象返回默认的迭代器，当用for-of时调用 |
| @@match | "Symbol.match" | 一个正则表达式方法，用来给字符串匹配正则表达式，当用String.prototype.match方法时调用 |
| @@replace | "Symbol.replace" | 一个正则表达式方法，用来替换匹配了的子字符串， 当用String.prototype.search 方法时调用 |
| @@search | "Symbol.search" | 一个正则表达式，返回正则表达式比配上的字符串的索引值，当用 String.prototype.search方法时调用 |
| @@species | "Symbol.species" | 用来构建派生对象的构造函数的函数值属性 |
| @@split | "Symbol.split" | 一个正则表达式方法，用来根据匹配上正则表达式的索引分割字符串 |
| @@toPrimitive | "Symbol.toPrimitive" | 一个用来把对象转换为原始值的函数，当用ToPrimitive时调用 |
| @@toStringTag | "Symbol.toStringTag" | 一个String值，用来创建默认String对象的描述，当用内置方法Object.prototype.toString方法时可访问 |
| @@unscopables | "Symbol.unscopables" | An object valued property whose own and inherited property names are property names that are excluded from the with environment bindings of the associated object |

### 6.1.6 Number类型

   准确的说，数值类型拥有 18437736874454810627（即2^64-2^53 +3）个值，表示为IEEE 754-2008标准64位双精度数值，在IEEE二进制浮点数算法中定义的，减去IEEE标准中的 9007199254740990（即2^53-2）个明显的“非数字”值，在 ECMAScript 中，它们被表示为一个单独的特殊值：NaN。（请注意，NaN值由程序表达式 NaN 产生，并假设执行程序不能调整定义的全局变量 NaN）。在某些实现中，外部代码可以识别出非数字值之间的不同，但是这依赖于具体实现，所有的NaN值都是无法互相区分的。

> 注意：在ArrayBuffer（24.1）的位模式中可能会发现存储的一个数字值不一定会相等于在ECMAScript中使用的值
 有两个特殊值，正无穷大和负无穷大，为简洁起见，这些值有时会被用+∞和 -∞表示（这两个无穷大值可以用+Infinity（或者Infinityh）和-Infinity产生\)  

其他18437736874454810627（即2^64-2^53 +3）个值称为有限值，一半是正值，一半是负值。对于每个正数而言，都有一个与之对应的、相同大小的负数。  
注意这里也有一个正零和负零，同样的为了简洁，会用+0和-0表示（注意这两个值也由+0\(0\)或者-0产生）  
这18437736874454810622 （2^64-2^53-2）个有限非零值分为两种：  
18428729675200069632 \(2^64-2^54\)个是格式化的，有如下格式:

```
s × m × 2^e
```

这里的s是+1或者-1，m是正整数，小于2^53大于2^52，e是一个从-1074到971的整数

剩下的9007199254740990（2^53-2）个值是非常规的，有如下格式：

```
s × m × 2^e
```

这里的s是+1或者-1，m是正整数，小于2^52，e是-1074

注意，所有绝对值不大于2^53的无论是正数还是负数都可以用Number类型来表示（甚至，0有两种表示方法，+0和-0）

一个有限的非零数值用上述的两种格式表示时，m是偶数，那他就有一个偶数标记，否则就有一个奇数标记

本规范中，当x表示一个精确的非零数值（甚至可以是无理数，比如π），"the Number value for x"这句话的意思就是以以下的方式选择一个数值：从所有有限数值集合中（不包括-0，包括2^1024和-2^2014这两个没法表示的值）选择一个最接近x的值。如果有两个是最接近x的值，那就选择有偶数标记的。2^1024和-2^1024都是当作有偶数标识的。最终，如果2^1024是最接近的那个值，用+∞代替，如果是-2^1024，那就用-∞代替，如果是+0，只有x&lt;0时，才会用-0代替。其他选择的值不会发生改变（这个过程是在符合IEEE 754-2008中的“round to nearest, ties to even”模式）。

一些ECMAScript操作符只会处理在-2^31到2^31 - 1 范围内的数值，或者0到2^16-1。这些操作符接受任何类型的Number类型，但是会先把操作数转换到所只会处理的范围，转换操作详见7.1

### 6.1.7 Object类型
一个Object是一个属性的集合，每个属性都是一个数据属性或者访问器属性
* 一个数据属性将关联一个[ECMAScript language value](6/6.1-ECMAScript-Language-Types.md)的key值，和一组Boolean属性
* 一个访问器属性将关联一个或者两个访问器函数，和一组Boolean属性，访问器函数用来对所关联的属性进行取值和赋值

属性是通过key值来访问的，一个属性的key值要么是ECMAScript String值，要么是Symbol值。所有的String和Symbol类型值，包括空字符串，都是合法的key。一个String类型的属性名可以作为属性key。  
一个整数索引是一个典型的数字字符串(如7.1.16中描述)，并且其数值是+0，或者小于2^53-1的正数，一个数组索引是一个大于+0，小于2^32-1的整数索引。  
属性键值是用来访问属性及获取其值得。这有两个操作：get、set,分别对应取值和赋值。通过get和set操作可以访问到的属性即包括对象自身的属性，还包括从其他对象继承而来的属性，继承而来的属性也可能是那个父对象的自身属性或者继承属性。对象的每个属性都必须拥有一个唯一的键值来区分不同属性。  
从逻辑上来说，所有的对象都是属性的集合，但是有非常多种形态的对象，他们有着不同的访问属性和操作属性的语法。Ordinary objects 是最普通的一种对象形态，有着默认的语法。 exotic object是那种有任何属性语法和默认语法不一样的对象。  

#### 6.1.7.1 属性特性
特性是用来定义和解释本规范中的Object属性的状态。数据属性键值关联到如表2中所列的特性
##### 表2 数据属性的特性

| 特性名 | 取值范围 | 描述 |
|---|---|---|
| [[Value]] | 任何ECMAScript 语言类型 | 默认为undefined，通过get访问器来获取其值 |
| [[Writable]] | Boolean | 如果为false，不能通过[[Set]]操作来改变[[Value]] |
| [[Enumerable]] | Boolean | 如果为true，可以通过for-in枚举，否则就说明这个属性是不可枚举的 |
| [[Configurable]] | Boolean | 不能删除这个属性或者将其改为访问器属性，不能改变这个属性的特性（除了[[Value]]和把[[Writable]]改为false) |

一个访问器属性有如表3所列的特性
##### 表3 访问器属性特性

| 特性名 | 取值范围 | 描述 |
|---|---|---|
| [[Get]] | Object或者Undefined | 如果是Object值，那必须是个函数对象。每次调用 get 访问器来获取这个属性的值时，都会以空参数列表调用这个函数的内置属性[[Call]]方法 |
| [[Set]] | Object获取Undefined | 如果是Object值，那必须是个函数对象。每次调用 set 访问器来给这个属性赋值时，都会以将要赋值的那个值作为唯一参数调用这个函数的内置属性[[Call]]方法。[[Set]] 后操作可能会通过调用 [[Get]] 操作来作为返回值 |
| [[Enumerable]] | Boolean | 如果为true，可以通过for-in枚举，否则就说明这个属性是不可枚举的 |
| [[Configurable]] | Boolean | 如果为false, 不能删除该属性，也不能把该属性变成数据属性，也不能改变任何该属性的特性 |

如果本规范没有明确指出属性特性的初始值，那么其默认值在表4中给出
##### 表4 特性默认值
| 特性名| 默认值 |
|---|---|
| [[Value]] | undefined |
| [[Get]] | undefined |
| [[Set]] | undefined |
| [[Writable]] | false |
| [[Enumerable]] | false |
| [[Configurable]] | false |

#### 6.1.7.2 Object内置方法和内置属性
在ECMAScript中objects的确切语法，都是通过一种叫内部方法的算法定义的。ECMAScript引擎中的每个对象，都关联着一序列的在运行时定义的内部方法。这些内部方法并不是ECMAScript语言的一部分。在规范中定义它们完全是出于解释的目的。然而每种ECMAScript中的对象实现都必须实现规范中定义这些内部方法，具体实现取决于实现者。  
内部方法名是多态的，这意味着不同的对象调用同一个名字的方法会执行不同的算法。对象本身就是调用方法时的"target"。在运行时，如果某个实现去调用对象不支持的方法，就会抛出TypeError异常。  






















